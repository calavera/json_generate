package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestAliases(t *testing.T) {
	h := aliases("")
	assert.Len(t, h, 0)

	h = aliases("Foo:")
	assert.Len(t, h, 0)

	h = aliases("Foo:Bar")
	assert.Len(t, h, 1)
	assert.Equal(t, h["Bar"], "Foo")

	h = aliases("Foo:Bar,Qux:Quux")
	assert.Len(t, h, 2)
	assert.Equal(t, h["Bar"], "Foo")
	assert.Equal(t, h["Quux"], "Qux")

	h = aliases("Foo:Bar:Baz,Qux:Quux")
	assert.Len(t, h, 3)
	assert.Equal(t, h["Bar"], "Foo")
	assert.Equal(t, h["Baz"], "Foo")
	assert.Equal(t, h["Quux"], "Qux")
}

func TestFilterTypes(t *testing.T) {
	h := filterTypes("")
	assert.Len(t, h, 0)

	h = filterTypes("Foo:")
	assert.Len(t, h, 0)

	h = filterTypes("Foo:*time.Time")
	assert.Len(t, h, 1)
	assert.Equal(t, h["Foo"], "*time.Time")

	h = filterTypes("Foo:*time.Time,count:int64")
	assert.Len(t, h, 2)
	assert.Equal(t, h["Foo"], "*time.Time")
	assert.Equal(t, h["count"], "int64")
}

func TestCapitalize(t *testing.T) {
	c := capitalize("foo")
	assert.Equal(t, c, "Foo")

	c = capitalize("foo_bar")
	assert.Equal(t, c, "FooBar")

	c = capitalize("foo_url")
	assert.Equal(t, c, "FooURL")

	c = capitalize("http_url")
	assert.Equal(t, c, "HTTPURL")
}

func TestNormalizeImport(t *testing.T) {
	i, ok := normalizeImport("*url.URL")
	assert.True(t, ok)
	assert.Equal(t, "url", i)

	i, ok = normalizeImport("string")
	assert.False(t, ok)
	assert.Equal(t, "string", i)
}

var dumpTestCases = []struct {
	source   *Source
	name     string
	output   string
	location string
	content  string
}{
	{
		source: &Source{
			name:    "event",
			pkg:     "main",
			structs: map[string]string{"Event": "type Event struct{}"},
			imports: make([]string, 0),
		},
		name:     "Event",
		output:   "",
		location: "event_json.go",
		content: `// generated by json_generate; DO NOT EDIT
package main

type Event struct{}`,
	},
	{
		source: &Source{
			name:    "event",
			pkg:     "main",
			structs: map[string]string{"Event": "type Event struct{}"},
			imports: []string{"url"},
		},
		name:     "Event",
		output:   "",
		location: "event_json.go",
		content: `// generated by json_generate; DO NOT EDIT
package main

import "url"

type Event struct{}`,
	},
}

func TestDump(t *testing.T) {
	temp, err := ioutil.TempDir("", "json-")
	if !assert.NoError(t, err) {
		return
	}
	defer os.RemoveAll(temp)

	for _, c := range dumpTestCases {
		w := newWalker([]string{}, nil, nil)

		w.sources = map[string]*Source{c.name: c.source}
		w.dump(c.output, temp)

		file := fmt.Sprintf("%s/%s", temp, c.location)
		fi, err := os.Stat(file)
		if !assert.NoError(t, err) {
			return
		}
		assert.False(t, fi.IsDir())

		content, err := ioutil.ReadFile(file)
		if !assert.NoError(t, err) {
			return
		}
		assert.Equal(t, string(content), c.content)
	}
}

var parseTestCases = []struct {
	aliases  map[string]string
	types    map[string]string
	src      string
	eLen     int
	ePkg     string
	eStructs map[string]string
}{
	{
		src:      "package main\nconst JSONExample_Event = `{ \"test_url\": \"http://foobar\", \"hits\": 8 }`",
		eLen:     1,
		ePkg:     "main",
		eStructs: map[string]string{"Event": "type Event struct {\n\tHits float64 `json:\"hits,omitempty\"`\n\tTestURL *url.URL `json:\"test_url,omitempty\"`\n}"},
	},
	{
		src:      "package main\nconst JSONExample_Event = `{ \"empty_array\": [] }`",
		eLen:     1,
		ePkg:     "main",
		eStructs: map[string]string{"Event": "type Event struct {\n\tEmptyArray []interface{} `json:\"empty_array,omitempty\"`\n}"},
	},
	{
		src:      "package main\nconst JSONExample_Event = `{ \"struct_array\": [{\"hits\": 9}] }`",
		eLen:     1,
		ePkg:     "main",
		eStructs: map[string]string{"Event": "type Event struct {\n\tStructArray []interface{} `json:\"struct_array,omitempty\"`\n}"},
	},
	{
		aliases: map[string]string{"Owner": "User"},
		src:     "package main\nconst JSONExample_User = `{\"login\": \"calavera\"}`\nconst JSONExample_Event = `{ \"owner\": {\"login\": \"calavera\"} }`",
		eLen:    2,
		ePkg:    "main",
		eStructs: map[string]string{
			"User":  "type User struct {\n\tLogin string `json:\"login,omitempty\"`\n}",
			"Event": "type Event struct {\n\tOwner *User `json:\"owner,omitempty\"`\n}",
		},
	},
	{
		src:  "package main\nconst JSONExample_Event = `{ \"user\": {\"login\": \"calavera\" }}`",
		eLen: 2,
		ePkg: "main",
		eStructs: map[string]string{
			"User":  "type User struct {\n\tLogin string `json:\"login,omitempty\"`\n}",
			"Event": "type Event struct {\n\tUser *User `json:\"user,omitempty\"`\n}",
		},
	},
	{
		src:  "package main\nconst JSONExample_Event = `{ \"user\": null }`",
		eLen: 1,
		ePkg: "main",
		eStructs: map[string]string{
			"Event": "type Event struct {\n\tUser string `json:\"user,omitempty\"`\n}",
		},
	},
	{
		types: map[string]string{"timestamp": "*time.Time"},
		src:   "package main\nconst JSONExample_Event = `{ \"timestamp\": 1420941101 }`",
		eLen:  1,
		ePkg:  "main",
		eStructs: map[string]string{
			"Event": "type Event struct {\n\tTimestamp *time.Time `json:\"timestamp,omitempty\"`\n}",
		},
	},
	{
		types: map[string]string{"Timestamp": "*time.Time"},
		src:   "package main\nconst JSONExample_Event = `{ \"timestamp\": 1420941101 }`",
		eLen:  1,
		ePkg:  "main",
		eStructs: map[string]string{
			"Event": "type Event struct {\n\tTimestamp *time.Time `json:\"timestamp,omitempty\"`\n}",
		},
	},
	{
		src:  "package main\nconst JSONExample_Event = `{ \"created_at\": 1420941101 }`",
		eLen: 1,
		ePkg: "main",
		eStructs: map[string]string{
			"Event": "type Event struct {\n\tCreatedAt *time.Time `json:\"created_at,omitempty\"`\n}",
		},
	},
}

func TestWalkerParseWithUnknownExample(t *testing.T) {
	w := newWalker([]string{"EventExample"}, nil, nil)

	input := strings.NewReader("package main\nconst JSONExample_Event = `{ \"test_url\": \"http://foobar\", \"hits\": 8 }`")

	s := w.parse("test.go", input)
	assert.Len(t, s.structs, 0)
}

func TestWalkerParse(t *testing.T) {
	parseTestHelper(t, []string{})
}

func TestWalkerParseWithExamples(t *testing.T) {
	parseTestHelper(t, []string{"User", "Event"})
}

func parseTestHelper(t *testing.T, examples []string) {
	for _, c := range parseTestCases {
		w := newWalker(examples, c.aliases, c.types)

		input := strings.NewReader(c.src)

		s := w.parse("test.go", input)
		assert.Equal(t, s.PathName(), "test")

		assert.Len(t, s.structs, c.eLen)
		assert.Equal(t, s.pkg, c.ePkg)

		for n, e := range c.eStructs {
			assert.Equal(t, s.structs[n], e)
		}
	}
}
