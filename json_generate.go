package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
)

const (
	jsonExamplePrefix = "JSONExample_"
	urlSuffix         = "_url"
	atSuffix          = "_at"
	urlTypeName       = "*url.URL"
	timeTypeName      = "*time.Time"
)

var (
	rawExamples = flag.String("example", "", "comma-separated list of json example names; all if not set")
	rawAliases  = flag.String("alias", "", "comma-separated list of struct alias names; i.e: Reference:Ref,User:Owner:Creator")
	rawTypes    = flag.String("types", "", "comma-separated list of type aliases by attribute name; i.e: UpdateAt:*time.Time,followers:int64")
	output      = flag.String("output", "", "output file name; default srcdir/<type>_json.go")
	debug       = flag.Bool("debug", false, "show output in STDOUT rather than generating files")

	initialisms = map[string]bool{
		"http": true,
		"id":   true,
		"ip":   true,
		"url":  true,
	}
)

type Source struct {
	name    string
	pkg     string
	structs map[string]string
	imports []string
}

func newSource(name string) *Source {
	return &Source{
		name:    name,
		structs: make(map[string]string),
		imports: make([]string, 0),
	}
}

func (s *Source) PathName() string {
	return strings.TrimSuffix(s.name, ".go")
}

func (s *Source) AddStruct(name, src string) {
	s.structs[name] = src
}

type walker struct {
	examples      map[string]bool
	aliases       map[string]string
	types         map[string]string
	parsedStructs map[string]bool
	sources       map[string]*Source
}

func newWalker(examples []string, aliases map[string]string, types map[string]string) *walker {
	checkedExamples := make(map[string]bool)
	for _, e := range examples {
		checkedExamples[e] = true
	}

	return &walker{
		examples:      checkedExamples,
		aliases:       aliases,
		types:         types,
		parsedStructs: make(map[string]bool),
		sources:       make(map[string]*Source),
	}
}

func (w *walker) filterType(name, field string, t reflect.Type) string {
	//TODO(calavera): Use pattern matching over the keys to allow filtering like *_url:Struct
	if f, ok := w.types[name]; ok {
		return f
	}

	if f, ok := w.types[field]; ok {
		return f
	}

	if strings.HasSuffix(field, urlSuffix) {
		return urlTypeName
	}

	if strings.HasSuffix(field, atSuffix) {
		return timeTypeName
	}

	return t.String()
}

func (w *walker) generate(output, root string, files ...string) {
	if len(files) == 0 {
		filepath.Walk(root, w.walk)
	} else {
		for _, f := range files {
			w.walk(f, nil, nil)
		}
	}

	w.dump(output, root)
}

func (w *walker) walk(path string, info os.FileInfo, err error) error {
	if !isDirectory(path) {
		w.sources[path] = w.parse(path, nil)
	}

	return nil
}

func (w *walker) dump(output, root string) {
	for _, src := range w.sources {
		b := bytes.NewBufferString("")
		b.WriteString("// generated by json_generate; DO NOT EDIT\n")
		b.WriteString(fmt.Sprintf("package %s", src.pkg))

		if len(src.imports) > 0 {
			b.WriteString("\n")
			for _, i := range src.imports {
				b.WriteString(fmt.Sprintf("\nimport \"%s\"", i))
			}
		}

		for _, s := range src.structs {
			b.WriteString(fmt.Sprintf("\n\n%s", s))
		}

		if *debug {
			fmt.Println(b.String())
		} else {
			if output == "" {
				baseName := fmt.Sprintf("%s_json.go", src.PathName())
				output = filepath.Join(root, strings.ToLower(baseName))
			}

			err := ioutil.WriteFile(output, b.Bytes(), 0644)
			if err != nil {
				log.Fatal("Error writing output: %q", err)
			}
		}
	}
}

func (w *walker) parse(p string, in io.Reader) *Source {
	fs := token.NewFileSet()
	pf, err := parser.ParseFile(fs, p, in, 0)
	if err != nil {
		log.Fatalf("parsing file: %s: %q", p, err)
	}

	src := newSource(path.Base(p))
	src.pkg = pf.Name.Name

	ast.Inspect(pf, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.ValueSpec:
			name := x.Names[0].Name

			if strings.HasPrefix(name, jsonExamplePrefix) && x.Values != nil {
				exampleName := strings.TrimPrefix(name, jsonExamplePrefix)

				_, ok := w.examples[exampleName]
				_, done := w.parsedStructs[exampleName]

				if !done && (len(w.examples) == 0 || ok) { // parse when it's a specific example or we want all of them
					switch f := x.Values[0].(type) {
					case *ast.BasicLit:
						clean := strings.Trim(f.Value, "`")
						dec := json.NewDecoder(strings.NewReader(clean))

						var m map[string]interface{}
						if err := dec.Decode(&m); err != nil && err != io.EOF {
							log.Fatal(err)
						}

						sMessage := w.transform(m, src)

						src.AddStruct(exampleName, createStruct(exampleName, sMessage))
						w.parsedStructs[exampleName] = true
					}
				}
			}
		}
		return true
	})

	return src
}

func (w *walker) transform(m map[string]interface{}, src *Source) string {
	s := bytes.NewBufferString("")

	fields := make([]string, 0)

	for k, v := range m {
		name := capitalize(k)

		if v != nil {
			tp := reflect.TypeOf(v)

			switch tp.Kind() {
			case reflect.Map:
				elType := name
				if a, ok := w.aliases[name]; ok {
					elType = a
				} else {
					sMessage := w.transform(v.(map[string]interface{}), src)

					src.AddStruct(name, createStruct(name, sMessage))
					w.parsedStructs[name] = true
				}
				fields = append(fields, fmt.Sprintf("\n\t%s *%s `json:\"%s,omitempty\"`", name, elType, k))
			case reflect.Array:
			case reflect.Slice:
				fields = append(fields, fmt.Sprintf("\n\t%s []interface{} `json:\"%s,omitempty\"`", name, k))
			default:
				ct := w.filterType(name, k, tp)
				if im, ok := normalizeImport(ct); ok {
					src.imports = append(src.imports, im)
				}
				fields = append(fields, fmt.Sprintf("\n\t%s %s `json:\"%s,omitempty\"`", name, ct, k))
			}
		} else {
			fields = append(fields, fmt.Sprintf("\n\t%s string `json:\"%s,omitempty\"`", name, k))
		}
	}

	sort.Strings(fields)

	for _, f := range fields {
		s.WriteString(f)
	}

	return s.String()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("json_generate: ")
	flag.Usage = usage
	flag.Parse()

	generateStructs(*rawExamples, *rawAliases, *rawTypes, *output, flag.Args()...)
}

func generateStructs(rawExamples, rawAliases, rawTypes, output string, args ...string) {
	if len(args) == 0 {
		args = []string{"."}
	}

	var e []string
	if rawExamples != "" {
		e = strings.Split(rawExamples, ",")
	}
	w := newWalker(e, aliases(rawAliases), filterTypes(rawTypes))

	if len(args) == 1 && isDirectory(args[0]) {
		w.generate(output, args[0])
	} else {
		root := filepath.Dir(args[0])
		w.generate(output, root, args...)
	}
}

func usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tjson_generate [flags] -example E [directory]\n")
	fmt.Fprintf(os.Stderr, "\tjson_generate [flags[ -example E files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func createStruct(name, body string) string {
	return fmt.Sprintf(`type %s struct {%s
}`, name, body)
}

func capitalize(name string) string {
	a := strings.Split(name, "_")
	b := bytes.NewBufferString("")

	for _, e := range a {
		if _, ok := initialisms[e]; ok {
			b.WriteString(strings.ToUpper(e))
		} else {
			b.WriteString(strings.Title(e))
		}
	}

	return b.String()
}

func filterTypes(rawFilterTypes string) map[string]string {
	a := make(map[string]string)
	if rawFilterTypes == "" {
		return a
	}

	l := strings.Split(rawFilterTypes, ",")
	for _, tuple := range l {
		kv := strings.Split(strings.TrimSpace(tuple), ":")

		if kv[1] == "" {
			log.Printf("Ignoring invalid type tuple: %s", tuple)
			continue
		}

		a[kv[0]] = kv[1]
	}

	return a
}

func aliases(rawAliases string) map[string]string {
	a := make(map[string]string)
	if rawAliases == "" {
		return a
	}

	l := strings.Split(rawAliases, ",")
	for _, tuple := range l {
		kv := strings.Split(strings.TrimSpace(tuple), ":")

		for idx := 1; idx < len(kv); idx++ {
			if kv[idx] == "" {
				log.Printf("Ignoring invalid empty alias in tuple: %s", tuple)
				continue
			}

			a[kv[idx]] = kv[0]
		}
	}

	return a
}

func isDirectory(name string) bool {
	fi, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return fi.IsDir()
}

func normalizeImport(t string) (string, bool) {
	if !strings.Contains(t, ".") {
		return t, false
	}
	it := strings.Split(t, ".")
	return strings.TrimLeft(it[0], "*"), true
}
